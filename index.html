<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dark Chat Overlay mit Audio, Screen & Datei-Upload</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#121214;
      --surface:#1c1c1e;
      --header:#1f1f1f;
      --accent:#007aff;
      --success:#28a745;
      --text:#e5e5ea;
      --muted:#8e8e93;
      --radius:8px;
      --shadow:0 4px 12px rgba(0,0,0,0.5);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    body.with-notice .header {
      margin-top: 40px;
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      padding: 10px;
      background: var(--header);
      box-shadow: var(--shadow);
    }

    .header button, .header select, .header label {
      height: 36px;
      padding: 0 12px;
      background: #242426;
      border: 1px solid #333;
      border-radius: var(--radius);
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .spacer { flex: 1; }

    #chatBody {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 10px;
      transition: all 0.3s ease;
    }

    .chat-input {
      display: none;
      padding: 12px;
      background: var(--surface);
      border-top: 1px solid #333;
      transition: all 0.3s ease;
    }

    .chat-input textarea {
      width: 100%;
      height: 60px;
      padding: 10px;
      border: 1px solid #333;
      border-radius: var(--radius);
      background: #242426;
      color: var(--text);
      resize: none;
      font-size: 14px;
    }

    .message {
      padding: 10px 14px;
      border-radius: var(--radius);
      max-width: 70%;
      word-break: break-word;
      box-shadow: var(--shadow);
      position: relative;
    }

    .user {
      background: linear-gradient(to right, var(--accent), #0051b0);
      color: #fff;
      align-self: flex-end;
      border-bottom-right-radius: 0;
    }

    .assistant {
      background: linear-gradient(to right, #2c2c2c, #1a1a1a);
      align-self: flex-start;
      border-bottom-left-radius: 0;
    }

    .timestamp {
      font-size: 12px;
      color: var(--muted);
      text-align: right;
      margin-top: 4px;
    }

    #remoteScreen {
      position: fixed;
      bottom: 12px;
      right: 12px;
      width: 320px;
      height: 180px;
      display: none;
      border: 2px solid var(--accent);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      background: black;
      object-fit: contain;
      z-index: 10;
    }

    #remoteScreen:fullscreen {
      width: 100vw;
      height: 100vh;
    }

    #fullscreenBtn {
      position: fixed;
      bottom: 200px;
      right: 12px;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: var(--radius);
      padding: 6px 12px;
      cursor: pointer;
      display: none;
      z-index: 999;
    }

    #screenNotice {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: var(--success);
      color: white;
      padding: 10px 16px;
      text-align: center;
      font-weight: 600;
      font-size: 15px;
      z-index: 9999;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from { transform: translateY(-100%); opacity: 0; }
      to   { transform: translateY(0); opacity: 1; }
    }

    audio { display: none; }
    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div id="screenNotice">üü¢ Bildschirm wird geteilt</div>

  <div class="header">
    <button id="connectBtn" style="background: red;">üîå Verbinden</button>
    <select id="micSelect" title="Mikrofon"></select>
    <select id="qualitySelect" title="Qualit√§t">
      <option value="1280x720">HD (720p)</option>
      <option value="1920x1080">Full HD (1080p)</option>
      <option value="2560x1440" selected>2K (1440p)</option>
      <option value="3840x2160">4K (2160p)</option>
    </select>
    <button id="screenBtn">üñ•Ô∏è Teilen</button>
    <label id="uploadBtn" title="Dateien hochladen">
      üìÅ Hochladen
      <input id="fileInput" type="file" multiple style="display: none;">
    </label>
    <button id="clearBtn">üóëÔ∏è Leeren</button>
    <div class="spacer"></div>
    <div id="userList" style="padding: 8px; font-size: 0.85rem; color: var(--muted);"></div>
  </div>

  <div id="chatBody"></div>
  <div class="chat-input">
    <textarea id="messageInput" placeholder="Nachricht schreiben..."></textarea>
  </div>

  <video id="remoteScreen" autoplay playsinline></video>
  <button id="fullscreenBtn">üîé Vollbild</button>
  <audio id="remoteAudio" autoplay></audio>

 const socket = io('/', { autoConnect: false });

let peer = null;
let localStream = null;
let remoteStream = new MediaStream();
let connected = false;

const connectBtn = document.getElementById('connectBtn');
const micSelect = document.getElementById('micSelect');
const chat = document.getElementById('chatBody');
const inputArea = document.querySelector('.chat-input');
const msg = document.getElementById('messageInput');
const clear = document.getElementById('clearBtn');
const screenBtn = document.getElementById('screenBtn');
const fileInput = document.getElementById('fileInput');
const userList = document.getElementById('userList');
const video = document.getElementById('remoteScreen');
const remoteAudio = document.getElementById('remoteAudio');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const screenNotice = document.getElementById('screenNotice');

// üé§ Pegelanzeige
const audioCtx = new AudioContext();
let meterNode = null;

async function loadMicrophones() {
  try {
    await navigator.mediaDevices.getUserMedia({ audio: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    micSelect.innerHTML = '';
    devices.filter(d => d.kind === 'audioinput').forEach((d, i) => {
      const option = document.createElement('option');
      option.value = d.deviceId;
      option.text = d.label || `Mikrofon ${i + 1}`;
      micSelect.appendChild(option);
    });
  } catch (err) {
    console.error('‚ö†Ô∏è Mikrofonfehler:', err);
  }
}

loadMicrophones();

connectBtn.onclick = async () => {
  connected = !connected;
  if (connected) {
    connectBtn.style.background = 'green';
    chat.style.display = 'flex';
    inputArea.style.display = 'block';
    socket.connect();
    socket.emit('join', 'default');
    socket.emit('get_users', 'default');

    const selectedMic = micSelect.value;
    localStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: selectedMic ? { exact: selectedMic } : undefined,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
        channelCount: 1
      }
    });

    showAudioLevel(localStream);

    initPeer();
    localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

    const offer = await peer.createOffer();
    await peer.setLocalDescription(offer);
    socket.emit('offer', { offer, room: 'default' });
  } else {
    socket.disconnect();
    if (peer) peer.close();
    if (localStream) localStream.getTracks().forEach(t => t.stop());
    connectBtn.style.background = 'red';
    chat.style.display = 'none';
    inputArea.style.display = 'none';
    screenNotice.style.display = 'none';
    document.body.classList.remove('with-notice');
  }
};

screenBtn.onclick = async () => {
  const [w, h] = document.getElementById('qualitySelect').value.split('x').map(Number);
  const screenStream = await navigator.mediaDevices.getDisplayMedia({
    video: { width: { ideal: w }, height: { ideal: h }, frameRate: { ideal: 30 } }
  });

  screenStream.getTracks().forEach(track => peer.addTrack(track, screenStream));
  const offer = await peer.createOffer();
  await peer.setLocalDescription(offer);
  socket.emit('offer', { offer, room: 'default' });

  screenNotice.style.display = 'block';
  document.body.classList.add('with-notice');

  screenStream.getVideoTracks()[0].addEventListener('ended', () => {
    screenNotice.style.display = 'none';
    document.body.classList.remove('with-notice');
  });
};

function initPeer() {
  peer = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  });

  remoteStream = new MediaStream();
  video.srcObject = remoteStream;
  remoteAudio.srcObject = remoteStream;

  peer.ontrack = e => {
    e.streams[0].getTracks().forEach(track => {
      if (!remoteStream.getTracks().some(t => t.id === track.id)) {
        remoteStream.addTrack(track);
      }
    });
    video.style.display = 'block';
    fullscreenBtn.style.display = 'block';
  };

  peer.onicecandidate = e => {
    if (e.candidate) socket.emit('ice', { candidate: e.candidate, room: 'default' });
  };
}

socket.on('offer', async data => {
  const selectedMic = micSelect.value;
  localStream = await navigator.mediaDevices.getUserMedia({
    audio: {
      deviceId: selectedMic ? { exact: selectedMic } : undefined,
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      sampleRate: 48000,
      channelCount: 1
    }
  });

  showAudioLevel(localStream);

  initPeer();
  localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
  await peer.setRemoteDescription(new RTCSessionDescription(data.offer));
  const answer = await peer.createAnswer();
  await peer.setLocalDescription(answer);
  socket.emit('answer', { answer, room: 'default' });
});

socket.on('answer', async data => {
  await peer.setRemoteDescription(new RTCSessionDescription(data.answer));
});

socket.on('ice', async data => {
  if (data.candidate) {
    try {
      await peer.addIceCandidate(new RTCIceCandidate(data.candidate));
    } catch (err) {
      console.error('‚ùå ICE Fehler:', err);
    }
  }
});

msg.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    if (!msg.value.trim()) return;
    socket.emit('message', { room: 'default', user: 'User', text: msg.value });
    appendMsg('Du', msg.value, 'user');
    msg.value = '';
  }
});

socket.on('message', d => appendMsg(d.user, d.text, 'assistant'));

socket.on('users', users => {
  userList.innerHTML = 'üßë‚Äçü§ù‚Äçüßë Verbundene IPs:<br>' + users.map(u => `‚Ä¢ ${u}`).join('<br>');
});

clear.onclick = () => chat.innerHTML = '';

fileInput.addEventListener('change', async () => {
  const files = Array.from(fileInput.files);
  if (!files.length) return;
  const formData = new FormData();
  files.forEach(file => formData.append('files', file));
  try {
    const res = await fetch('/upload', { method: 'POST', body: formData });
    const result = await res.json();
    result.files.forEach(f => appendMsg('Du', `üìé <a href=\"${f.url}\" target=\"_blank\">${f.name}</a>`, 'user'));
  } catch (err) {
    alert('Upload fehlgeschlagen!');
    console.error(err);
  } finally {
    fileInput.value = '';
  }
});

function appendMsg(name, text, type) {
  const t = new Date().toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
  chat.innerHTML += `<div class=\"message ${type}\"><strong>${name}:</strong> ${text}<div class=\"timestamp\">${t}</div></div>`;
  chat.scrollTop = chat.scrollHeight;
}

// üîä Pegelanzeige einblenden
function showAudioLevel(stream) {
  const micSource = audioCtx.createMediaStreamSource(stream);
  meterNode = audioCtx.createAnalyser();
  meterNode.fftSize = 32;
  micSource.connect(meterNode);

  const dataArray = new Uint8Array(meterNode.frequencyBinCount);
  const interval = setInterval(() => {
    meterNode.getByteFrequencyData(dataArray);
    const volume = Math.max(...dataArray);
    connectBtn.textContent = volume > 5 ? `üéôÔ∏è ${volume}` : 'üîå Verbunden';
    if (!connected) clearInterval(interval);
  }, 200);
}




  

</body>
</html>
