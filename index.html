<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dark Chat Overlay mit Audio, Screen & Datei-Upload</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    /* ... (CSS bleibt unverÃ¤ndert) ... */
  </style>
</head>
<body>
  <!-- Hinweisleiste -->
  <div id="screenNotice">ğŸŸ¢ Bildschirm wird geteilt</div>

  <!-- Header mit Version, Nutzername, Controls -->
  <div class="header">
    <span id="version"></span>
    <input id="usernameInput" placeholder="Benutzername" />
    <button id="connectBtn" style="background: red;">ğŸ”Œ Verbinden</button>
    <select id="micSelect" title="Mikrofon"></select>
    <select id="qualitySelect" title="QualitÃ¤t">
      <option value="1280x720">HD (720p)</option>
      <option value="1920x1080">Full HD (1080p)</option>
      <option value="2560x1440" selected>2K (1440p)</option>
      <option value="3840x2160">4K (2160p)</option>
    </select>
    <button id="screenBtn">ğŸ–¥ï¸ Teilen</button>
    <label id="uploadBtn" title="Dateien hochladen">
      ğŸ“ Hochladen
      <input id="fileInput" type="file" multiple style="display: none;">
    </label>
    <button id="clearBtn">ğŸ—‘ï¸ Leeren</button>
    <div class="spacer"></div>
    <div id="userList"></div>
  </div>

  <!-- Chat-Bereich -->
  <div id="chatBody"></div>
  <div class="chat-input">
    <textarea id="messageInput" placeholder="Nachricht schreiben..."></textarea>
  </div>

  <!-- Remotescreen & Audio -->
  <video id="remoteScreen" autoplay playsinline></video>
  <button id="fullscreenBtn">ğŸ” Vollbild</button>
  <audio id="remoteAudio" autoplay></audio>

  <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
  <script>
    // Version
    const VERSION = '1.0.0';
    document.getElementById('version').textContent = 'v' + VERSION;

    // Elemente referenzieren
    const socket = io('/', { autoConnect: false });
    const connectBtn = document.getElementById('connectBtn');
    const chat = document.getElementById('chatBody');
    const inputArea = document.querySelector('.chat-input');
    const msg = document.getElementById('messageInput');
    const clear = document.getElementById('clearBtn');
    const screenBtn = document.getElementById('screenBtn');
    const video = document.getElementById('remoteScreen');
    const micSelect = document.getElementById('micSelect');
    const qualitySelect = document.getElementById('qualitySelect');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const remoteAudio = document.getElementById('remoteAudio');
    const fileInput = document.getElementById('fileInput');
    const screenNotice = document.getElementById('screenNotice');
    const userList = document.getElementById('userList');
    const usernameInput = document.getElementById('usernameInput');

    let connected = false;
    let peer = null;
    let localStream = null;
    let remoteStream = new MediaStream();
    let username = '';

    // Vorher gespeicherten Nutzernamen laden
    if (localStorage.getItem('username')) {
      usernameInput.value = localStorage.getItem('username');
    }

    // Mikrofone laden
    async function loadMicrophones() {
      try {
        await navigator.mediaDevices.getUserMedia({ audio: true });
        const devices = await navigator.mediaDevices.enumerateDevices();
        micSelect.innerHTML = '';
        devices.filter(d => d.kind === 'audioinput').forEach((d,i) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.text = d.label || `Mic ${i+1}`;
          micSelect.append(opt);
        });
      } catch (e) {
        console.error('Mikrofonzugriff verweigert:', e);
      }
    }
    loadMicrophones();

    // Peer-Verbindung initialisieren
    function initPeer() {
      peer = new RTCPeerConnection();
      remoteStream = new MediaStream();
      video.srcObject = remoteStream;
      remoteAudio.srcObject = remoteStream;

      // Wenn eine neue Spur ankommt
      peer.ontrack = e => {
        e.streams[0].getTracks().forEach(track => {
          if (!remoteStream.getTracks().some(t => t.id === track.id)) {
            remoteStream.addTrack(track);
          }
        });
        video.style.display = 'block';
        fullscreenBtn.style.display = 'block';
      };

      // ICE-Kandidaten senden
      peer.onicecandidate = e => {
        if (e.candidate) {
          socket.emit('ice', { candidate: e.candidate, room: 'default' });
        }
      };
    }

    // Neu aushandeln (z.B. bei neuem Teilnehmer)
    async function negotiate() {
      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);
      socket.emit('offer', { offer, room: 'default', user: username });
    }

    // Verbindung aufbauen/abbauen
    connectBtn.onclick = async () => {
      if (!usernameInput.value.trim()) {
        alert('Bitte Benutzernamen eingeben.');
        return;
      }
      username = usernameInput.value.trim();
      localStorage.setItem('username', username);

      connected = !connected;
      if (connected) {
        connectBtn.style.background = 'green';
        chat.style.display = 'flex';
        inputArea.style.display = 'block';

        socket.connect();
        socket.emit('join', 'default');
        socket.emit('get_users', 'default');

        // Lokales Audio
        const micId = micSelect.value;
        localStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: micId } } });

        initPeer();
        localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

        // Erstes Angebot
        await negotiate();
      } else {
        connectBtn.style.background = 'red';
        chat.style.display = 'none';
        inputArea.style.display = 'none';

        socket.disconnect();
        peer && peer.close();
        localStream && localStream.getTracks().forEach(t => t.stop());

        screenNotice.style.display = 'none';
        document.body.classList.remove('with-notice');
      }
    };

    // Bildschirm teilen
    screenBtn.onclick = async () => {
      const [w, h] = qualitySelect.value.split('x').map(Number);
      const screenStream = await navigator.mediaDevices.getDisplayMedia({
        video: { width: { ideal: w }, height: { ideal: h }, frameRate: { ideal: 30 } }
      });
      screenStream.getTracks().forEach(track => peer.addTrack(track, screenStream));
      await negotiate();

      screenNotice.style.display = 'block';
      document.body.classList.add('with-notice');

      screenStream.getVideoTracks()[0].addEventListener('ended', () => {
        screenNotice.style.display = 'none';
        document.body.classList.remove('with-notice');
      });
    };

    // Socket-Events
    socket.on('offer', async data => {
      // Antwortende Seite
      const micId = micSelect.value;
      localStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: micId } } });
      initPeer();
      localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

      await peer.setRemoteDescription(new RTCSessionDescription(data.offer));
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);
      socket.emit('answer', { answer, room: 'default' });
    });

    socket.on('answer', async data => {
      await peer.setRemoteDescription(new RTCSessionDescription(data.answer));
    });

    socket.on('ice', async data => {
      if (data.candidate) {
        try {
          await peer.addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch (e) {
          console.error('ICE-Fehler', e);
        }
      }
    });

    // Neu aushandeln, wenn ein weiterer Nutzer beitritt
    socket.on('new_user', async () => {
      if (connected && peer) {
        await negotiate();
      }
    });

    // Chat-FunktionalitÃ¤t
    msg.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (!msg.value.trim()) return;
        socket.emit('message', { room: 'default', user: username, text: msg.value });
        appendMsg(username, msg.value, 'user');
        msg.value = '';
      }
    });

    socket.on('message', d => appendMsg(d.user, d.text, 'assistant'));

    // User-Liste aktualisieren
    socket.on('users', users => {
      userList.innerHTML = 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Verbundene:<br>' + users.map(u => `â€¢ ${u}`).join('<br>');
    });

    // Chat leeren
    clear.onclick = () => chat.innerHTML = '';

    // Datei-Upload
    fileInput.addEventListener('change', async () => {
      const files = Array.from(fileInput.files);
      if (!files.length) return;
      const formData = new FormData();
      files.forEach(f => formData.append('files', f));
      try {
        const res = await fetch('/upload', { method: 'POST', body: formData });
        if (!res.ok) throw new Error(res.statusText);
        const result = await res.json();
        result.files.forEach(f => appendMsg(username, `ğŸ“ <a href="${f.url}" target="_blank">${f.name}</a>`, 'user'));
      } catch (e) {
        alert('Upload fehlgeschlagen!');
        console.error(e);
      } finally {
        fileInput.value = '';
      }
    });

    // Hilfsfunktion fÃ¼r Chat-Nachrichten
    function appendMsg(name, text, type) {
      const t = new Date().toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
      chat.innerHTML += `<div class=\"message ${type}\"><strong>${name}:</strong> ${text}<div class=\"timestamp\">${t}</div></div>`;
      chat.scrollTop = chat.scrollHeight;
    }
  </script>
</body>
</html>
